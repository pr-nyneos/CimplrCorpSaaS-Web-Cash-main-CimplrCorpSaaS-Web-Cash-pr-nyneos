import * as XLSX from "xlsx";
import { saveAs } from "file-saver";
import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";

// Helper to get user email from localStorage
function getUserEmail() {
  if (typeof window !== "undefined" && window.localStorage) {
    return localStorage.getItem("userEmail") || "Unknown User";
  }
  return "Unknown User";
}

export const exportToExcel = (data: any[], filename: string, options?: { fxType?: string }) => {
  const fxType = options?.fxType;
  const title = fxType ? `FX ${fxType} Report` : "FX Report";
  const today = new Date();
  const dateString = today.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
  const userEmail = getUserEmail();

  if (!data || data.length === 0) {
    const worksheet = XLSX.utils.json_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
    const excelBuffer = XLSX.write(workbook, { bookType: "xlsx", type: "array" });
    const blob = new Blob([excelBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    });
    saveAs(blob, `${filename}.xlsx`);
    return;
  }

  const headers = Object.keys(data[0]);
  
  // Prepare worksheet data with header rows
  const worksheetData = [
    [title], // Row 1: Title
    [`Date: ${dateString}    Total Records: ${data.length}    Generated by: ${userEmail}`], // Row 2: Info
    headers, // Row 3: Column headers
    ...data.map(row => headers.map(h => row[h])), // Data rows
  ];

  const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

  // Define colors
  const colors = {
    primary: "4472C4",  // Dark blue
    secondary: "8EA9DB", // Light blue
    accent: "F2F2F2",   // Light gray
    textDark: "000000", // Black
    textLight: "FFFFFF", // White
    headerBg: "5B9BD5", // Medium blue
    dataRowBg: "FFFFFF", // White
    alternateRowBg: "E7EFF7" // Very light blue
  };

  // Styling for all cells (default style)
  const fullSheetRange = XLSX.utils.decode_range(worksheet['!ref']!);
  for (let R = 0; R <= fullSheetRange.e.r; ++R) {
    for (let C = 0; C <= fullSheetRange.e.c; ++C) {
      const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
      if (!worksheet[cellAddress]) continue;
      
      // Default cell style
      worksheet[cellAddress].s = {
        font: { sz: 11, color: { rgb: colors.textDark } },
        fill: { fgColor: { rgb: R % 2 === 0 ? colors.dataRowBg : colors.alternateRowBg } },
        alignment: { horizontal: "left", vertical: "center" },
        border: {
          top: { style: "thin", color: { rgb: "D9D9D9" } },
          bottom: { style: "thin", color: { rgb: "D9D9D9" } },
          left: { style: "thin", color: { rgb: "D9D9D9" } },
          right: { style: "thin", color: { rgb: "D9D9D9" } }
        }
      };
    }
  }

  // Title row (A1)
  worksheet["A1"].s = {
    font: { bold: true, sz: 24, color: { rgb: colors.textLight } },
    fill: { fgColor: { rgb: colors.primary } },
    alignment: { horizontal: "center", vertical: "center" }
  };
  // Merge title row across all columns
  // const lastCol = XLSX.utils.encode_col(headers.length - 1);
  worksheet["!merges"] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } }];

  // Info row (A2)
  worksheet["A2"].s = {
    font: { bold: true, italic: true, sz: 12, color: { rgb: colors.textDark } },
    fill: { fgColor: { rgb: colors.secondary } },
    alignment: { horizontal: "center", vertical: "center" }
  };
  // Merge info row across all columns
  worksheet["!merges"].push({ s: { r: 1, c: 0 }, e: { r: 1, c: headers.length - 1 } });

  // Column headers row (row 3)
  for (let i = 0; i < headers.length; i++) {
    const cell = worksheet[XLSX.utils.encode_cell({ r: 2, c: i })];
    if (cell) {
      cell.s = {
        font: { bold: true, sz: 14, color: { rgb: colors.textLight } },
        fill: { fgColor: { rgb: colors.headerBg } },
        alignment: { horizontal: "center", vertical: "center" },
        border: {
          top: { style: "medium", color: { rgb: colors.primary } },
          bottom: { style: "medium", color: { rgb: colors.primary } },
          left: { style: "thin", color: { rgb: "D9D9D9" } },
          right: { style: "thin", color: { rgb: "D9D9D9" } }
        }
      };
    }
  }

  // Set column widths based on header/content length
  worksheet["!cols"] = headers.map(header => {
    const headerLength = header.length;
    const maxContentLength = Math.max(
      ...data.map(row => 
        row[header] ? row[header].toString().length : 0
      )
    );
    return { wch: Math.min(30, Math.max(15, Math.max(headerLength, maxContentLength) + 2)) };
  });

  // Freeze headers (first 3 rows)
  worksheet["!freeze"] = { x: 0, y: 3 };

  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Report");

  // Write with cell styles
  const excelBuffer = XLSX.write(workbook, {
    bookType: "xlsx",
    type: "array",
    cellStyles: true,
  });

  const blob = new Blob([excelBuffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  });

  saveAs(blob, `${filename}.xlsx`);
};
export const exportToPDF = (
  data: any[],
  filename: string,
  columns: any[],
  fxType?: string
) => {
  try {
    const doc = new jsPDF('landscape');
    const pageWidth = doc.internal.pageSize.getWidth();

    const title = fxType ? `FX ${fxType} Report` : 'FX Report';
    const today = new Date();
    const dateString = today.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
    const userEmail = getUserEmail();

    // Title Bar
    doc.setFillColor(41, 128, 185);
    doc.rect(0, 0, pageWidth, 28, 'F');
    doc.setFontSize(18);
    doc.setTextColor(255, 255, 255);
    doc.text(title, pageWidth / 2, 14, { align: 'center' });

    // Sub-header
    doc.setFontSize(10);
    doc.setTextColor(255, 255, 255);
    doc.text(`Date: ${dateString}`, 14, 24);
    doc.text(`Total Records: ${data.length}`, pageWidth - 40, 24, { align: 'right' });

    // Filter only present columns
    const presentColumns = columns.filter(col => {
      const key = col.accessorKey || col.id;
      return data.some(item => Object.prototype.hasOwnProperty.call(item, key));
    });

    // Split columns into chunks of 12
    const chunkSize = 12;
    for (let i = 0; i < presentColumns.length; i += chunkSize) {
      const chunk = presentColumns.slice(i, i + chunkSize);

      const headers = chunk.map(col =>
        col.header || (col.columnDef?.header) || col.accessorKey || col.id
      );

      const formattedData = data.map(item =>
        chunk.map(col => {
          const key = col.accessorKey || col.id;
          let value = item[key];
          if (value === undefined || value === null) return '';
          if (typeof value === 'string' && value.match(/\d{4}-\d{2}-\d{2}/)) {
            return new Date(value).toLocaleDateString();
          }
          return String(value);
        })
      );

      autoTable(doc, {
        startY: i === 0 ? 32 : undefined,
        head: [headers],
        body: formattedData,
        styles: {
          fontSize: 7,
          cellPadding: 2,
          overflow: 'linebreak',
          halign: 'left',
          valign: 'middle',
          minCellWidth: 20,
          textColor: [33, 33, 33],
        },
        headStyles: {
          fillColor: [41, 128, 185],
          textColor: [255, 255, 255],
          fontStyle: 'bold',
          fontSize: 8,
        },
        alternateRowStyles: {
          fillColor: [245, 245, 245],
        },
        margin: {
          top: i === 0 ? 32 : 10,
          left: 8,
          right: 8,
        },
        tableWidth: 'auto',
        didDrawPage: (dataArg) => {
          // Footer: right-aligned
          doc.setFontSize(8);
          doc.setTextColor(150, 150, 150);
          const footerText = `Generated by: ${userEmail}    Generated on: ${dateString}`;
          doc.text(
            footerText,
            pageWidth - 10,
            doc.internal.pageSize.height - 10,
            { align: 'right' }
          );
          // Page number (center)
          doc.text(
            `Page ${dataArg.pageNumber}`,
            doc.internal.pageSize.width / 2,
            doc.internal.pageSize.height - 10,
            { align: 'center' }
          );
        },
      });

      // Add a page if more column chunks are left
      if (i + chunkSize < presentColumns.length) {
        doc.addPage();
      }
    }

    doc.save(`${filename}.pdf`);
  } catch (error) {
    console.error("PDF export error:", error);
    alert("Failed to export PDF. Check console for details.");
  }
};

// Export to Word function
export const exportToWord = async (
  data: any[],
  filename: string,
  columns: any[],
  options?: { fxType?: string }
) => {
  try {
    const fxType = options?.fxType;
    const title = fxType ? `FX ${fxType} Report` : "Bank Balance Report";
    const today = new Date();
    const dateString = today.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
    const userEmail = getUserEmail();

    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>${title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { background-color: #2980b9; color: white; padding: 15px; text-align: center; margin-bottom: 20px; }
          .title { font-size: 24px; font-weight: bold; margin-bottom: 5px; }
          .info { font-size: 14px; }
          table { width: 100%; border-collapse: collapse; margin: 20px 0; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #3498db; color: white; font-weight: bold; }
          tr:nth-child(even) { background-color: #f2f2f2; }
          .footer { margin-top: 30px; font-size: 12px; color: #666; }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="title">${title}</div>
          <div class="info">Date: ${dateString} | Total Records: ${data.length} | Generated by: ${userEmail}</div>
        </div>
        
        <table>
          <thead>
            <tr>
              ${columns.map(col => `<th>${col.header || col.accessorKey || col.id}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
            ${data.map(row => `
              <tr>
                ${columns.map(col => {
                  const key = col.accessorKey || col.id;
                  let value = row[key];
                  if (value === undefined || value === null) value = '';
                  if (typeof value === 'string' && value.match(/\d{4}-\d{2}-\d{2}/)) {
                    value = new Date(value).toLocaleDateString();
                  }
                  return `<td>${String(value)}</td>`;
                }).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
        
        <div class="footer">
          <p>Generated on: ${dateString} by ${userEmail}</p>
        </div>
      </body>
      </html>
    `;

    const blob = new Blob([htmlContent], {
      type: "application/msword"
    });

    saveAs(blob, `${filename}.doc`);
  } catch (error) {
    console.error("Word export error:", error);
    alert("Failed to export to Word. Check console for details.");
  }
};
